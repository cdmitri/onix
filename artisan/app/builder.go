/*
  Onix Config Manager - Artisan
  Copyright (c) 2018-2021 by www.gatblau.org
  Licensed under the Apache License, Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0
  Contributors to this project, hereby assign copyright in this code to the project,
  to be licensed under the same terms as the rest of the code.
*/

package app

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// Builder the contract for application deployment configuration builders
type Builder interface {
	Build() ([]DeploymentRsx, error)
}

func NewBuilder(builder BuilderType, appManifest Manifest) (Builder, error) {
	switch builder {
	case DockerCompose:
		return newComposeBuilder(appManifest), nil
	case Kubernetes:
		return newKubeBuilder(appManifest), nil
	}
	return nil, fmt.Errorf("builder type not supported\n")
}

type DeploymentRsxType int

const (
	ComposeProject DeploymentRsxType = iota
	K8SResource
	EnvironmentFile
	ConfigurationFile
	SvcInitScript
	DeployScript
	BuildFile
)

type DeploymentRsx struct {
	Name    string
	Content []byte
	Type    DeploymentRsxType
}

type BuilderType int

const (
	DockerCompose BuilderType = iota
	Kubernetes
)

// GenerateResources generates application deployment resources for a particular platform specified by the format parameter
// uri: the uri of the application manifest to use to generate resources
// format: the resources platform format (e.g. compose, k8s)
// profile: the application profile name, that describes the services to generate from the application manifest
// creds: credentials to get the app manifest from git service in the format uname:pwd - if not required pass empty string
// path: the file path where the resources should be saved
func GenerateResources(uri, format, profile, creds, path string) error {
	// create an application manifest
	manifest, err := NewAppMan(uri, profile, creds)
	if err != nil {
		return err
	}
	// create a builder
	var builderType BuilderType
	switch strings.ToLower(format) {
	case "compose":
		builderType = DockerCompose
	case "k8s":
		builderType = Kubernetes
	default:
		return fmt.Errorf("invalid format, valid formats are compose or k8s")
	}
	builder, err := NewBuilder(builderType, *manifest)
	if err != nil {
		return err
	}
	// build the app deployment resources
	files, err := builder.Build()
	if err != nil {
		return err
	}
	// work out a target path
	path, err = filepath.Abs(path)
	if err != nil {
		return err
	}
	// ensure path exists
	if _, err = os.Stat(path); os.IsNotExist(err) {
		err = os.MkdirAll(path, os.ModePerm)
		if err != nil {
			return fmt.Errorf("cannot create folder '%s': %s\n", path, err)
		}
	}
	// a builder to aggregate init scripts
	script := newScriptBuilder()
	// write files to disk
	for _, file := range files {
		// skips init scripts until
		if file.Type == SvcInitScript {
			_, err = script.WriteString(fmt.Sprintf("# ================================================\n# %s\n# ================================================\n", file.Name))
			if err != nil {
				return err
			}
			_, err = script.Write(file.Content)
			if err != nil {
				return err
			}
			script.WriteString("\n")
			continue
		}
		// if the path contains a directory
		if !isFilename(file.Name) {
			// if it is absolute
			if isAbs(file.Name) {
				// makes the directory relative (removes leading slash)
				file.Name = file.Name[1:]
			}
			// creates the relative directory
			dir, err2 := filepath.Abs(filepath.Join(path, filepath.Dir(file.Name)))
			if err2 != nil {
				return err
			}
			err = os.MkdirAll(dir, os.ModePerm)
			if err != nil {
				return err
			}
		}
		fpath := filepath.Join(path, file.Name)
		err = os.WriteFile(fpath, file.Content, os.ModePerm)
		if err != nil {
			return fmt.Errorf("cannot write configuration file %s: %s\n", fpath, err)
		}
	}
	// finally, constructs an init script for the whole app
	fpath := filepath.Join(path, "init.sh")
	err = os.WriteFile(fpath, []byte(script.String()), os.ModePerm)
	if err != nil {
		return fmt.Errorf("cannot write init file %s: %s\n", fpath, err)
	}
	return nil
}

func isAbs(path string) bool {
	// the path is considered absolute if:
	// a. starts with a forward slash
	// b. contains at least two forward slashes
	return len(strings.Split(path, "/")) > 1 && path[0] == '/'
}

func isFilename(path string) bool {
	// the path is considered a filename only if it does not contain any forward slashes
	return strings.Index(path, "/") == -1
}

func newScriptBuilder() *strings.Builder {
	script := &strings.Builder{}
	script.WriteString("#!/bin/bash\n")
	script.WriteString(fmt.Sprintf("# ONIX CONFIG MANAGER initialisation script for docker-compose services\n# auto-generated by Onix Artisan on %s\n", time.Now().UTC()))
	artExist := `
if ! command -v art &> /dev/null; then
	echo "art is required but not installed"
	exit
fi
`
	script.WriteString(artExist)
	dbmanExist := `
if ! command -v dbman &> /dev/null; then
	echo "dbman is required but not installed"
	exit
fi
`
	script.WriteString(dbmanExist)
	script.WriteString("\nset -o allexport; source .env; set +o allexport\n\n")
	return script
}
